{% extends "base.html" %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
<div class="card">
    <h1>ðŸ“¡ {{ title }}</h1>
    <p><strong>Target Host:</strong> {{ host }}</p>
    <p><strong>Status:</strong> <span class="status-indicator status-online"></span> <span id="connection-status">Monitoring...</span></p>
    <p><strong>Last Update:</strong> <span id="last-update">--</span></p>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-value" id="packets-sent">0</div>
        <div class="stat-label">Packets Sent</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="packets-received">0</div>
        <div class="stat-label">Packets Received</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="packet-loss">0%</div>
        <div class="stat-label">Packet Loss</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="avg-latency">--</div>
        <div class="stat-label">Avg Latency</div>
    </div>
</div>

<div class="card">
    <h2>ðŸ“Š Real-time Ping Results</h2>
    <div class="log-container" id="ping-log">
        <div class="log-line">Initializing ping monitor for {{ host }}...</div>
        <div class="log-line">Waiting for data...</div>
    </div>
</div>

<div class="card">
    <h2>ðŸ“ˆ Connection Statistics</h2>
    <div id="stats-container">
        <div class="log-line">Statistics will appear here as data is collected...</div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    const pingType = '{{ type }}';
    const host = '{{ host }}';
    const logContainer = document.getElementById('ping-log');
    
    let packetsSent = 0;
    let packetsReceived = 0;
    let latencies = [];
    
    // Listen for real-time ping updates
    socket.on(`ping_update_${pingType}`, function(data) {
        const logLine = document.createElement('div');
        logLine.className = 'log-line';
        
        const timestamp = formatTimestamp(data.timestamp);
        let content = data.data;
        let lineClass = '';
        
        // Parse ping results for statistics
        if (content.includes('Reply from')) {
            packetsReceived++;
            lineClass = 'success';
            
            // Extract latency
            const latencyMatch = content.match(/time=(\d+)ms/);
            if (latencyMatch) {
                latencies.push(parseInt(latencyMatch[1]));
            }
        } else if (content.includes('Request timed out') || content.includes('timeout')) {
            lineClass = 'error';
        } else if (content.includes('Packets: Sent')) {
            // Extract packet statistics
            const sentMatch = content.match(/Sent = (\d+)/);
            const receivedMatch = content.match(/Received = (\d+)/);
            if (sentMatch) packetsSent = parseInt(sentMatch[1]);
            if (receivedMatch) packetsReceived = parseInt(receivedMatch[1]);
            lineClass = 'warning';
        }
        
        logLine.innerHTML = `${timestamp} ${content}`;
        if (lineClass) logLine.classList.add(lineClass);
        
        logContainer.appendChild(logLine);
        autoScroll(logContainer);
        
        // Update statistics
        updateStats();
        
        // Update last update time
        document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
    });
    
    function updateStats() {
        document.getElementById('packets-sent').textContent = packetsSent;
        document.getElementById('packets-received').textContent = packetsReceived;
        
        // Calculate packet loss
        const loss = packetsSent > 0 ? ((packetsSent - packetsReceived) / packetsSent * 100).toFixed(1) : 0;
        document.getElementById('packet-loss').textContent = `${loss}%`;
        
        // Calculate average latency
        if (latencies.length > 0) {
            const avgLatency = (latencies.reduce((a, b) => a + b, 0) / latencies.length).toFixed(1);
            document.getElementById('avg-latency').textContent = `${avgLatency}ms`;
        }
        
        // Update connection status
        const statusElement = document.getElementById('connection-status');
        const statusIndicator = document.querySelector('.status-indicator');
        
        if (packetsReceived > 0) {
            statusElement.textContent = 'Connected';
            statusIndicator.className = 'status-indicator status-online';
        } else if (packetsSent > 0) {
            statusElement.textContent = 'Connection Issues';
            statusIndicator.className = 'status-indicator status-warning';
        }
    }
    
    // Load recent logs on page load
    fetch(`/api/logs/${pingType}_ping`)
        .then(response => response.json())
        .then(data => {
            if (data.lines && data.lines.length > 0) {
                logContainer.innerHTML = '';
                data.lines.slice(-50).forEach(line => {
                    const logLine = document.createElement('div');
                    logLine.className = 'log-line';
                    logLine.innerHTML = line;
                    
                    if (line.includes('Reply from')) {
                        logLine.classList.add('success');
                    } else if (line.includes('timeout')) {
                        logLine.classList.add('error');
                    }
                    
                    logContainer.appendChild(logLine);
                });
                autoScroll(logContainer);
            }
        })
        .catch(error => console.error('Error loading logs:', error));
</script>
{% endblock %}
